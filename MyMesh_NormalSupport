// Nathan Pham
// CS451 Autumn 2017
// November 17th, 2017
// This script extends MyMesh class to calculate the normal vectors
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

struct Triangle
{
    int v1 , v2, v3;
    public Triangle(int V1, int V2, int V3)
    {
        v1 = V1;
        v2 = V2;
        v3 = V3;
    }
    public int GetV1() { return v1; }
    public int GetV2() { return v2; }
    public int GetV3() { return v3; }
}

public partial class MyMesh : MonoBehaviour
{
    LineSegment[] mNormals;
    List<Triangle> triangles = new List<Triangle>();

    void InitNormals(Vector3[] v, Vector3[] n)
    {
        mNormals = new LineSegment[v.Length];
        for (int i = 0; i < v.Length; i++)
        {
            GameObject o = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
            mNormals[i] = o.AddComponent<LineSegment>();
            mNormals[i].SetWidth(0.05f);
            mNormals[i].transform.SetParent(this.transform);
        }
        UpdateNormals(v, n);
    }

    void UpdateNormals(Vector3[] v, Vector3[] n)
    {
        for (int i = 0; i < v.Length; i++)
        {
            mNormals[i].SetEndPoints(v[i], v[i] + 1.0f * n[i]);
        }
    }

    Vector3 FaceNormal(Vector3[] v, int i0, int i1, int i2)
    {
        Vector3 a = v[i1] - v[i0];
        Vector3 b = v[i2] - v[i0];
        return Vector3.Cross(a, b).normalized;
    }

    void ComputeNormals(Vector3[] v, Vector3[] n)
    {
        Vector3[] triNormal = new Vector3[numCol * numRows * 2];
        int triInd = 0;

        // If using Visual Studio, extend the code using the + on the side
        #region Calculate_Normals_At_Each_Face
        // Perform the triangle counting cycle @ The initialize triangle mesh
        for (int i = 0; i < (numRows * numCol) - numRows - 1; i++)
        {
            Debug.Log("N_Tri i: " + i);
            if ((i + 1) % (numRows) == 0) // if the next number is the edge, skip it
            {
                Debug.Log("N_Skipped Tri i: " + i);
                i++;
                Debug.Log("N_Now Tri i: " + i);
            }
            // first normal
            triNormal[triInd] = FaceNormal(v,i, i + numRows, i + numRows + 1);
            triangles.Add(new Triangle(i, i + numRows, i + numRows + 1));

            // second normal
            Debug.Log("N_Triindex +1: " + (triInd +1));
            triNormal[triInd + 1] = FaceNormal(v, i ,i + numRows + 1, i + 1);
            triangles.Add(new Triangle(i, i + numRows + 1, i + 1));

            triInd += 2; // move to the next row
            Debug.Log("N_Triindex : " + triInd);
        }
        #endregion

        #region Determine_Where_Triangles_Intersect
        for (int i = 0; i < n.Length; i++)
        {
            Vector3 norm = Vector3.zero;
            // perform superposition on any normals where the triangle connects each other
            for(int j = 0; j < triNormal.Length; j++)
            {
                Triangle tri = triangles[j];
                if (tri.GetV1() == i || tri.GetV2() == i || tri.GetV3() == i)
                    norm += triNormal[j];
            }
            n[i] = norm.normalized; // the resulting vector is the average of the other normals
        }
        #endregion

        UpdateNormals(v, n);
    }
}
